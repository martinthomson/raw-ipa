use super::gen::generate_events;
use super::run::generate_report;

use log::{debug, error, info};
use raw_ipa::cli::Verbosity;
use std::fs::File;
use std::path::PathBuf;
use std::{io, process};
use structopt::StructOpt;

const DEFAULT_EVENT_GEN_COUNT: u32 = 100_000;

#[derive(Debug, StructOpt)]
pub struct CommonArgs {
    #[structopt(flatten)]
    pub logging: Verbosity,

    #[structopt(
        short,
        long,
        global = true,
        help = "Write the result to the file.",
        parse(from_os_str)
    )]
    output_file: Option<PathBuf>,

    #[structopt(long, global = true, help = "Overwrite the specified output file.")]
    overwrite: bool,
}

#[derive(Debug, StructOpt)]
#[structopt(name = "ipa_bench", about = "Synthetic data test harness for IPA")]
pub struct Args {
    #[structopt(flatten)]
    pub common: CommonArgs,

    #[structopt(subcommand)]
    pub cmd: Command,
}

#[derive(Debug, StructOpt)]
#[structopt(name = "command")]
pub enum Command {
    Init {
        #[structopt(
            short,
            long,
            default_value = "1",
            help = "Multiply the number of events generated by the scale factor. For example, --scale-factor=100 generates 10,000,000 synthetic events."
        )]
        scale_factor: u32,

        #[structopt(
            short,
            long,
            help = "Random generator seed. Setting the seed allows reproduction of the synthetic data exactly."
        )]
        random_seed: Option<u64>,

        #[structopt(
            short,
            long,
            default_value = "0",
            help = "Simulate ads created in this epoch. Impressions and conversions for a given ad may happen in the next epoch."
        )]
        epoch: u8,

        #[structopt(long, help = "Output secret shared values")]
        secret_share: bool,
    },

    Run {
        #[structopt(
            short,
            long,
            help = "File containing source and trigger events. If not set, stdin will be used.",
            parse(from_os_str)
        )]
        input_file: Option<PathBuf>,

        #[structopt(
            short,
            long,
            default_value = "28",
            help = "Attribution window in days. Trigger events within the window are attributed to the preceeding source event."
        )]
        attribution_window: u32,

        #[structopt(
            short,
            long,
            possible_values = &["LastTouch", "Linear", "TimeDecay"],
            default_value = "LastTouch",
        )]
        model: String,
    },
}

impl Command {
    pub fn dispatch(&self, common: &CommonArgs) {
        info!("Command {:?}", self);

        match self {
            Self::Init {
                scale_factor,
                random_seed,
                epoch,
                secret_share,
            } => {
                Command::init(common, *scale_factor, random_seed, *epoch, *secret_share);
            }

            Self::Run {
                input_file,
                attribution_window,
                model,
            } => Command::run(common, input_file, *attribution_window, model),
        }
    }

    // Execute [init] subcommand
    fn init(
        common: &CommonArgs,
        scale_factor: u32,
        random_seed: &Option<u64>,
        epoch: u8,
        secret_share: bool,
    ) {
        let mut out = get_output(&common.output_file, common.overwrite).unwrap_or_else(|e| {
            error!("Failed to open the output file. {}", e);
            process::exit(1);
        });

        info!(
            "scale: {}, seed: {:?}, epoch: {}",
            scale_factor, random_seed, epoch
        );
        debug!(
            "Total number of events to generate: {}",
            DEFAULT_EVENT_GEN_COUNT * scale_factor
        );

        let (s_count, t_count) = generate_events(
            DEFAULT_EVENT_GEN_COUNT * scale_factor,
            epoch,
            secret_share,
            random_seed,
            &mut out,
        );

        info!("{} source events generated", s_count);
        info!("{} trigger events generated", t_count);
        info!(
            "trigger/source ratio: {}",
            f64::from(t_count) / f64::from(s_count)
        );
    }

    fn run(
        common: &CommonArgs,
        input_file: &Option<PathBuf>,
        attribution_window: u32,
        model: &str,
    ) {
        let mut input = get_input(input_file).unwrap_or_else(|e| {
            error!("Failed to open the input file. {}", e);
            process::exit(1);
        });

        let mut out = get_output(&common.output_file, common.overwrite).unwrap_or_else(|e| {
            error!("Failed to open the output file. {}", e);
            process::exit(1);
        });

        info!(
            "input: {:?}, attribution_window: {}, model: {}",
            input_file, attribution_window, model
        );

        generate_report(&mut input, attribution_window, model, &mut out);
    }
}

fn get_input(path: &Option<PathBuf>) -> Result<Box<dyn io::Read>, io::Error> {
    match path {
        Some(ref path) => File::open(path).map(|f| Box::new(f) as Box<dyn io::Read>),
        None => Ok(Box::new(io::stdin())),
    }
}

fn get_output(path: &Option<PathBuf>, overwrite: bool) -> Result<Box<dyn io::Write>, io::Error> {
    match path {
        Some(ref path) => {
            let mut file = File::options();

            if overwrite {
                file.truncate(true).create(true);
            } else {
                file.create_new(true);
            }

            file.write(true)
                .open(path)
                .map(|f| Box::new(f) as Box<dyn io::Write>)
        }
        None => Ok(Box::new(io::stdout())),
    }
}
